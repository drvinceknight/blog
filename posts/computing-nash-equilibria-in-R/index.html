<!DOCTYPE html>
<html>
<head>
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Using vertex enumeration to compute equilibria in R">

<link rel="icon" href="/blog/assets/favicon.ico" type="image/x-icon">

<!-- Modified version of hack.css -->
<link rel="stylesheet" href="/blog/assets/css/hack.css">

<!-- Solarized color scheme -->
<link rel="stylesheet" href="/blog/assets/css/solarized-light.min.css" ></link>

<!-- notebook css style -->
  <link rel="stylesheet" href="/blog/assets/css/notebook.css">

<!-- Code syntax highlighting -->
<link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">

<script
src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<!-- MathJax -->
<script type="text/javascript" async
src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"
async>
</script>
<!-- MathJax configuration -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true,
        processEnvironments: true
    },
    // Center justify equations in code and markdown cells. Elsewhere
    // we use CSS to left justify single line equations in code cells.
    displayAlign: 'center',
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}},
        linebreaks: { automatic: true }
    }
});
</script>
<!-- End of mathjax configuration -->
</head>

<h1><a href="/blog/">Un peu de math</a></h1>
<p>Using vertex enumeration to compute equilibria in R</p>

<body class="hack">
    <div class="main container">


<h2> Computing nash equilibria in R </h2>
<h3> 2020-02-26 </h3>

<hr />
<p>There are a number of ways of computing Nash equilibria for Normal Form Games 
defined by two matrices ((A, B)). The approach I'm going to describe here is
to use vertex enumeration. This is not necessarily the most efficient algorithm
(that honor goes to 
<a href="https://vknight.org/gt/chapters/07/">The Lemke Howson algorithm</a>). The vertex 
enumeration algorithm involves finding vertices of Polytopes and R has a nice 
library for that called <code>vertexenum</code>.</p>
<h3>The theory (skip if you just want the code)</h3>
<p>You can read my course notes on this here: 
<a href="https://vknight.org/gt/chapters/06/">vknight.org/gt/chapters/06/</a> but 
here is a brief outline:</p>
<ul>
<li>Consider a two player game defined by 
  ((A, B)\in\mathbb{R}^{({m \times n})^2}) where (A) denotes the row 
  player's utilities and (B) the column player's utilities.</li>
<li>Define the row player's best response polytope as:</li>
</ul>
<p>[
  \mathcal{P} = \left{x\in\mathbb{R}^{m}\;|\;x\geq 0; xB\leq 1\right}
  ]</p>
<ul>
<li>Define the row player's best response polytope as:</li>
</ul>
<p>[
  \mathcal{Q} = \left{y\in\mathbb{R}^{n}\;|\;Ay\leq 1; y\geq 0right}
  ]</p>
<ul>
<li>
<p>Elements of (\mathcal{P}, \mathcal{Q}) are labelled by the defining 
  inequalities for which they are binding. For example in (P) for (m=3) the 
  vertex (x=(0,0,0)) would have labels (1, 2, 3) as the first 3 inequlities 
  of (\mathcal{P}) are in fact equalities. In (Q) for (n=2) the  vertex 
  (y=(0,0)) would have labels (4, 5) as the last 2 inequlities of 
  (\mathcal{Q}) are in fact equalities.</p>
</li>
<li>
<p>Nash equilibria corresponds to pairs of vertices of (\mathcal{P}) and 
  (\mathcal{Q}) for which the union of the labels give the full set of 
  integers from (1) to (m + n). One such pair will always be the pair of 
  vertices with all values 0 (as in the previous bullet point)
  however this is a so called "artificial" equilibria.    </p>
</li>
<li>To convert these pairs of vertices to pairs of strategies, we normalise so 
  that their elements sum to 1.</li>
</ul>
<p>Throughout this blog post we will use the following game as an example:</p>
<p>[
  A = \begin{pmatrix}
    3 &amp; 1\
    0 &amp; 2
    \end{pmatrix}
  \quad
  B = \begin{pmatrix}
    2 &amp; 1\
    0 &amp; 3
    \end{pmatrix}
]</p>
<h3>Implementation of vertex enumeration in R.</h3>
<p>We are going to make use of the <code>vertexenum</code> library which given a general 
polytope will return all vertices. This library's function <code>enumerate.vertices</code> 
takes 2 inputs <code>M, b</code> that define the Polytope in the general form as 
(Mx\leq b).  So the first step is to create these two inputs from a given set 
of payoff matrices.</p>
<pre><code class="r">#' Returns the matrix M that corresponds to the column players best response
#' polytope defined by the row players utility matrix A.
#' 
#' @param A The row players utility matrix.
get_linear_system_coeffients &lt;- function(A) {
  dimensions &lt;- dim(A)
  number_of_row_strategies &lt;- dimensions[2]
  positivity_constraints &lt;- -diag(number_of_row_strategies)
  do.call(rbind, list(positivity_constraints, A))
}
</code></pre>

<p>For example if we use this on the row players utility matrix of our running 
example:</p>
<pre><code class="r">A &lt;- rbind(c(3, 1), c(0, 2))
A
</code></pre>

<pre><code>##      [,1] [,2]
## [1,]    3    1
## [2,]    0    2
</code></pre>

<p>We get:</p>
<pre><code class="r">get_linear_system_coeffients(A)
</code></pre>

<pre><code>##      [,1] [,2]
## [1,]   -1    0
## [2,]    0   -1
## [3,]    3    1
## [4,]    0    2
</code></pre>

<p>We also need to get the right hand side vector:</p>
<pre><code class="r">#' Returns the vector b that corresponds to the column players best response
#' polytope defined by the row players utility matrix A.
#' 
#' @param A The row players utility matrix.
get_linear_system_rhs &lt;- function(A) {
  dimensions &lt;- dim(A)
  number_of_col_strategies &lt;- dimensions[1]
  number_of_row_strategies &lt;- dimensions[2]
  c(rep(0, number_of_row_strategies), rep(1, number_of_col_strategies))
}
</code></pre>

<p>If we now use this we get:</p>
<pre><code class="r">get_linear_system_rhs(A)
</code></pre>

<pre><code>## [1] 0 0 1 1
</code></pre>

<p>We can use the <code>vertexenum</code> library to get the vertices of the row player's 
polytope:</p>
<pre><code class="r">library(vertexenum)
M &lt;- get_linear_system_coeffients(A)
b &lt;- get_linear_system_rhs(A)
enumerate.vertices(M, b)
</code></pre>

<pre><code>##           [,1] [,2]
## [1,] 0.1666667  0.5
## [2,] 0.0000000  0.5
## [3,] 0.3333333  0.0
## [4,] 0.0000000  0.0
</code></pre>

<p>For the row player we need to consider the transpose of (B) 
(as all of the code we have written is from the perspective of the column player):</p>
<pre><code class="r">B &lt;- rbind(c(2, 1), c(0, 3))
M &lt;- get_linear_system_coeffients(t(B))
b &lt;- get_linear_system_rhs(t(B))
enumerate.vertices(M, b)
</code></pre>

<pre><code>##      [,1]      [,2]
## [1,]  0.5 0.1666667
## [2,]  0.0 0.3333333
## [3,]  0.5 0.0000000
## [4,]  0.0 0.0000000
</code></pre>

<p>Given a vertex we want to know its labels (which of the defining inequalities 
are binding) so let us write a function to do that:</p>
<pre><code class="r">library(berryFunctions)
#' Returns the set of labels of a given vertex for the polytope defined
#' by M and b.
#' 
#' @param vertex The vertex
#' @param M The coefficient matrix defining the polytope
#' @param b The right hand side vector defining the polytope
get_labels &lt;- function(vertex, M, b) {
  almost.equal(c(M %*% vertex), b)
}
</code></pre>

<p>For example:</p>
<pre><code class="r">get_labels(c(1 / 2, 0), M, b)
</code></pre>

<pre><code>## [1] FALSE  TRUE  TRUE FALSE
</code></pre>

<p>We can now compute all vertices of a polytope and the corresponding labels:</p>
<pre><code class="r">#' Returns the set of vertices and labels for the column player's best 
#' response polytope.
#' The format of the output is:
#' 
#' x_1 x_2 ... x_n B_1 B_2 ... B_(m+n)
#'
#' Where B_i is 0 (False) or 1 (True) dependent on whether or not the vector has
#' label i.
#' 
#' @param A The row players utility matrix.
get_vertices &lt;- function(A) {
  M &lt;- get_linear_system_coeffients(A)
  b &lt;- get_linear_system_rhs(A)
  vertices &lt;- enumerate.vertices(M, b)
  vertices &lt;- vertices[rowSums(vertices) != 0, ]

  labels &lt;- t(apply(vertices, 1, function(vertex) {
    get_labels(vertex, M, b)
  }))
  cbind(vertices, labels)
}
</code></pre>

<pre><code class="r">col_vertices &lt;- get_vertices(A)
row_vertices &lt;- get_vertices(t(B))
col_vertices
</code></pre>

<pre><code>##           [,1] [,2] [,3] [,4] [,5] [,6]
## [1,] 0.1666667  0.5    0    0    1    1
## [2,] 0.0000000  0.5    1    0    0    1
## [3,] 0.3333333  0.0    0    1    1    0
</code></pre>

<pre><code class="r">row_vertices
</code></pre>

<pre><code>##      [,1]      [,2] [,3] [,4] [,5] [,6]
## [1,]  0.5 0.1666667    0    0    1    1
## [2,]  0.0 0.3333333    1    0    0    1
## [3,]  0.5 0.0000000    0    1    1    0
</code></pre>

<p>Using all of the above, we can now consider two potential vertices, and their 
labels and see if they form a fully labeled pair:</p>
<pre><code class="r">#' Returns whether or not a given pair of vertices is fully labeled.
#' Takes a vertex x in the following form:
#' 
#' x_1 x_2 ... x_n B_1 B_2 ... B_(m+n)
#'
#' Where B_i is 0 (False) or 1 (True) dependent on whether or not the vector has
#' label i.
#' 
#' @param x A row player vertex
#' @param y A column player vertex
#' @param number_of_row_strategies  # TODO Remove this as an argument.
#' @param number_of_col_strategies
is_fully_labeled &lt;- function(x,  
                             y, 
                             number_of_row_strategies, 
                             number_of_col_strategies) {
  dimension &lt;- number_of_row_strategies + number_of_col_strategies
  row_labels &lt;- (which(x[-c(1:number_of_row_strategies)] &gt; 0) %% dimension)
  col_labels &lt;- (which(y[-c(1:number_of_col_strategies)] &gt; 0) + number_of_row_strategies) %% dimension
  setequal(union(row_labels, col_labels), 0:(dimension - 1))
}
</code></pre>

<pre><code class="r">x &lt;- row_vertices[3, ]
y &lt;- col_vertices[3, ]
is_fully_labeled(x, y, 2, 2)
</code></pre>

<pre><code>## [1] TRUE
</code></pre>

<pre><code class="r">x &lt;- row_vertices[3, ]
y &lt;- col_vertices[2, ]
is_fully_labeled(x, y, 2, 2)
</code></pre>

<pre><code>## [1] FALSE
</code></pre>

<p>This gives us all the tools we need to iterate over all pairs of vertices and identify the fully labeled vertex pairs (and thus the Nash equilibria):</p>
<pre><code class="r">#' Return the nash equilibria for a two player game defined by utility matrices 
#' A and B
#'
#' @param A The row player utility matrix
#' @param B The column player utility matrix
obtain_nash_equilibra &lt;- function(A, B) {
  dimensions &lt;- dim(A)
  number_of_row_strategies &lt;- dimensions[1]
  number_of_col_strategies &lt;- dimensions[2]

  row_vertices &lt;- get_vertices(t(B))
  col_vertices &lt;- get_vertices(A)
  number_of_row_vertices &lt;- dim(row_vertices)[1]
  number_of_col_vertices &lt;- dim(col_vertices)[1]

  output &lt;- c()
  for (i in 1:number_of_row_vertices) {
    row_vertex_and_labels &lt;- row_vertices[i, ]
    for (j in 1:number_of_col_vertices) {
      column_vertex_and_labels &lt;- col_vertices[j, ]
      if (is_fully_labeled(
        x = row_vertex_and_labels,
        y = column_vertex_and_labels,
        number_of_row_strategies = number_of_row_strategies,
        number_of_col_strategies = number_of_col_strategies
      )) {
        row_vertex &lt;- head(row_vertex_and_labels, number_of_row_strategies)
        row_strategy &lt;- row_vertex / sum(row_vertex)
        column_vertex &lt;- head(column_vertex_and_labels, number_of_col_strategies)
        column_strategy &lt;- column_vertex / sum(column_vertex)

        max_size &lt;- max(number_of_row_strategies, number_of_col_strategies)
        length(row_strategy) &lt;- max_size
        length(column_strategy) &lt;- max_size

        output &lt;- rbind(output, row_strategy, column_strategy)
      }
    }
  }
  output
}
</code></pre>

<pre><code class="r">ne &lt;- obtain_nash_equilibra(A, B)
ne
</code></pre>

<pre><code>##                 [,1] [,2]
## row_strategy    0.75 0.25
## column_strategy 0.25 0.75
## row_strategy    0.00 1.00
## column_strategy 0.00 1.00
## row_strategy    1.00 0.00
## column_strategy 1.00 0.00
</code></pre>

<p>We see there that we have 3 Nash equilibria.</p>
<p>We can experiment with a slightly larger game, for example here is rock 
paper scissors:</p>
<pre><code class="r">rps &lt;- rbind(c(0, -1, 1), c(1, 0, -1), c(-1, 1, 0))
rps_row &lt;- rps + 2
rps_col &lt;- -rps + 2
ne &lt;- obtain_nash_equilibra(rps_row, rps_col)
ne
</code></pre>

<pre><code>##                      [,1]      [,2]      [,3]
## row_strategy    0.3333333 0.3333333 0.3333333
## column_strategy 0.3333333 0.3333333 0.3333333
</code></pre>

<p>And here is a non square game:</p>
<pre><code class="r">A &lt;- rbind(c(3, 3), c(2, 5), c(0, 6))
B &lt;- rbind(c(3, 2), c(2, 6), c(3, 1))
ne &lt;- obtain_nash_equilibra(A, B)
ne
</code></pre>

<pre><code>##                      [,1]      [,2]      [,3]
## row_strategy    0.8000000 0.2000000 0.0000000
## column_strategy 0.6666667 0.3333333        NA
## row_strategy    0.0000000 0.3333333 0.6666667
## column_strategy 0.3333333 0.6666667        NA
## row_strategy    1.0000000 0.0000000 0.0000000
## column_strategy 1.0000000 0.0000000        NA
</code></pre>

<p>There are a number of other (<strong>better</strong>) algorithms for computing equilbria and
the python <a href="https://nashpy.readthedocs.io/">Nashpy</a> library document has
reference material on them.</p>
<p>If you have any thoughts/improvement on the R code (I'm not terribly satisfied with how <code>obtain_nash_equilibria</code> is written for example), I'd welcome your thoughts: <a href="http://twitter.com/drvinceknight">@drvinceknight</a>.</p>


    <a href=/blog//var/folders/qt/7gg5106n5d5brwzgk8gxc_xm0000gn/T/tmpboi4rn1f>tmpboi4rn1f</a>




    </div>
</body>

<hr>

<div class="grid">
    <div class="cell -6of12">
        <div class="content">
            <p>
A blog about programming (usually scientific python), mathematics
(usually game theory) and learning (usually student centred pedagogic
approaches).</p>
        </div>
    </div>
    <div class="cell -3of12">
        <div class="content">
            Source code: <a href="https://github.com/drvinceknight/blog">
                          drvinceknight</a>
        </div>
        <div class="content">
            Twitter: <a href="https://twitter.com/drvinceknight">
                          @drvinceknight</a>
        </div>
        <div class="content">
            Email: <a href="mailto:knightva@cardiff.ac.uk">
                          knightva@cardiff.ac.uk</a>
        </div>
    </div>
    <div class="cell -3of12">
        <div class="content">
            Powered by:
        </div>
        <div class="content">
            <a href="https://www.python.org/">Python</a>
        </div>
        <div class="content">
            <a href="http://hackcss.egoist.moe/">hack.css</a>
        </div>
        <div class="content">
            <a href="http://thomasf.github.io/solarized-css/">solarized-css</a>
        </div>
        <div class="content">
            <a href="https://www.mathjax.org/">mathjax</a>
        </div>
        <div class="content">
            <a href="https://highlightjs.org/">highlight.js</a>
        </div>
        <div class="content">
            <a href="https://pages.github.com/">Github pages</a>
        </div>
        <ul>
    </div>
</html>